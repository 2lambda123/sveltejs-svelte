<script>
	import { onMount } from 'svelte';
	import * as fleece from 'golden-fleece';
	import SplitPane from './SplitPane.html';
	import CodeMirror from './CodeMirror.html';
	import Input from './Input/index.html';
	import Output from './Output/index.html';

	export let version;
	export let components;
	export let selectedComponent;
	export let data;
	export let json5;

	let bundle = null;
	let dom;
	let ssr;
	let sourceError = null;
	let runtimeError = null;
	let dataError = null;
	let dataErrorLoc = null;
	let warningCount = 0;
	let compiled = '';
	let uid = 0;

	let sourceErrorLoc, runtimeErrorLoc;

	let worker;

	onMount(async () => {
		worker = new Worker('/repl-worker.js');

		function listener(event) {
			switch (event.data.type) {
				case 'version':
					version = event.data.version;
					break;

				case 'bundled':
					({ bundle, dom, ssr, warningCount, error: sourceError } = event.data.result);
					runtimeError = null;
					break;

				case 'compiled':
					compiled = event.data.result;
					break;
			}
		}

		worker.addEventListener('message', listener);

		worker.postMessage({ type: 'init', version });

		return () => {
			worker.removeEventListener('message', listener);
			worker.terminate();
		};
	});

	function createComponent() {
		const newComponent = {
			name: uid++ ? `Component${uid}` : 'Component1',
			type: 'html',
			source: '',
			edit: true
		};

		components = components.concat(newComponent);

		setTimeout(() => {
			document.getElementById(newComponent.name).scrollIntoView(false);
			selectedComponent = newComponent;
		});
	}

	function removeComponent() {
		const component = selectedComponent;

		if (component.name === 'App') {
			// App.html can't be removed
			component.source = '';
			selectedComponent = component;
		} else {
			const index = components.indexOf(component);
			if (~index) {
				components = components.slice(0, index).concat(components.slice(index + 1));
			} else {
				console.error(`Could not find component! That's... odd`);
			}

			selectedComponent = components[index] || components[components.length - 1];
		}
	}

	function updateData(current) {
		const data = fleece.evaluate(json5);

		for (const key in data) {
			data[key] = current[key];
		}

		json5 = fleece.patch(json5, data);
	}

	function navigate(filename) {
		const name = filename.replace(/\.html$/, '');

		if (selectedComponent.name === name) return;
		selectedComponent = components.find(c => c.name === name);
	}

	$: if (sourceError && selectedComponent) {
		sourceErrorLoc = sourceError.filename === `${selectedComponent.name}.${selectedComponent.type}`
			? sourceError.start
			: null;
	}

	$: if (runtimeError && selectedComponent) {
		runtimeErrorLoc = runtimeError.filename === `${selectedComponent.name}.${selectedComponent.type}`
			? runtimeError.start
			: null;
	}

	$: try {
		data= fleece.evaluate(json5);
		dataError = null;
		dataErrorLoc = null;
	} catch (err) {
		dataError = err;
		dataErrorLoc = err && err.loc;
	}

	$: if (worker && components.length > 0) {
		worker.postMessage({ type: 'bundle', components });
	}

	let last_selected_component;
	$: {
		// slightly counterintuitively, we only want to rebundle if
		// this is the *same* component â€” not if we've just selected
		// a different one
		// if (selectedComponent === last_selected_component) {
		// 	if (worker && components.length > 0) {
		// 		console.log(`2`, components);
		// 		worker.postMessage({ type: 'bundle', components });
		// 	}
		// }

		// recompile the currently selected component
		if (selectedComponent) {
			if (selectedComponent.type === 'html') {
				worker.postMessage({ type: 'compile', component: selectedComponent });
			} else {
				compiled = selectedComponent.source;
			}
		}

		last_selected_component = selectedComponent;
	}
</script>

<style>
	.repl-inner { height: 100% }

	.repl-inner :global(section) {
		position: relative;
		padding: 4.2rem 0 0 0;
		height: 100%;
	}

	.repl-inner :global(section) > :global(*):first-child {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 4.2rem;
	}

	.repl-inner :global(section) > :global(*):last-child {
		width: 100%;
		height: 100%;
	}

	.repl-inner :global(.message) {
		position: relative;
		border-radius: var(--border-r);
		margin: 0;
		padding: 1.2rem 1.6rem 1.2rem 4.4rem;
		vertical-align: middle;
		font: 300 1.2rem/1.7 var(--font-ui);
		color: white;
	}

	.repl-inner :global(.message::before) {
		content: '!';
		position: absolute;
		left: 1.2rem;
		top: 1.1rem;
		width: 1rem;
		height: 1rem;
		text-align: center;
		line-height: 1;
		padding: .4rem;
		border-radius: 50%;
		color: white;
		border: .2rem solid white;
	}

	.repl-inner :global(.error.message) {
		background-color: #da106e;
	}

	.repl-inner :global(.warning.message) {
		background-color: #e47e0a;
	}

	.repl-inner :global(.info.message) {
		background-color: var(--second);
		animation: fade-in .4s .2s both;
	}

	.repl-inner :global(.error) :global(.filename) {
		cursor: pointer;
	}

	@media (min-width: 768px) {
		.show-if-mobile { display: none }

		.repl-outer.zen-mode {
			position: fixed;
			width: 100%;
			height: 100%;
			top: 0;
			left: 0;
			z-index: 11;
		}

		section { height: 100% }
	}
</style>

<div class="repl-inner">
	<SplitPane type="horizontal">
		<section slot=a>
			<Input
				{components}
				bind:selectedComponent
				error={sourceError}
				errorLoc="{sourceErrorLoc || runtimeErrorLoc}"
				{warningCount}
				on:create={createComponent}
				on:remove={removeComponent}
				on:select="{e => selectedComponent = e.detail.component}"
			/>
		</section>

		<section slot=b style='height: 100%;'>
			<Output
				{compiled}
				{bundle}
				{ssr}
				{dom}
				{data}
				{json5}
				{sourceError}
				{runtimeError}
				{dataError}
				{dataErrorLoc}
			/>
		</section>
	</SplitPane>
</div>