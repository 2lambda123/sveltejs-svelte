import { print } from 'esrap';
import { VERSION } from '../../../version.js';
import { server_component, server_module } from './server/transform-server.js';
import { client_component, client_module } from './client/transform-client.js';
import { getLocator } from 'locate-character';
import {
	apply_preprocessor_sourcemap,
	get_basename,
	get_relative_path,
	get_source_name
} from '../../utils/mapped_code.js';

/**
 * @param {import('../types').ComponentAnalysis} analysis
 * @param {string} source
 * @param {import('#compiler').ValidatedCompileOptions} options
 * @returns {import('#compiler').CompileResult}
 */
export function transform_component(analysis, source, options) {
	if (options.generate === false) {
		return {
			js: /** @type {any} */ (null),
			css: null,
			warnings: transform_warnings(source, options.filename, analysis.warnings),
			metadata: {
				runes: analysis.runes
			}
		};
	}

	const program =
		options.generate === 'server'
			? server_component(analysis, options)
			: client_component(source, analysis, options);

	const basename = (options.filename ?? 'Component').split(/[/\\]/).at(-1);
	if (program.body.length > 0) {
		program.body[0].leadingComments = [
			{
				type: 'Line',
				value: ` ${basename} (Svelte v${VERSION})`
			},
			{
				type: 'Line',
				value: ' Note: compiler output will change before 5.0 is released!'
			}
		];
	}

	const js_source_name = get_source_name(options.filename, options.outputFilename, 'input.svelte');
	const js = print(program, {
		// include source content; makes it easier/more robust looking up the source map code
		sourceMapContent: source,
		sourceMapSource: js_source_name
	});
	merge_with_preprocessor_map(js, options, js_source_name);

	const css =
		analysis.stylesheet.has_styles && !analysis.inject_styles
			? analysis.stylesheet.render(options.cssOutputFilename, source, options.dev)
			: null;
	if (css) {
		merge_with_preprocessor_map(css, options, css.map.sources[0]);
	}

	return {
		js,
		css,
		warnings: transform_warnings(source, options.filename, analysis.warnings), // TODO apply preprocessor sourcemap
		metadata: {
			runes: analysis.runes
		}
	};
}

/**
 * @param {{ code: string, map: import('magic-string').SourceMap}} result
 * @param {import('#compiler').ValidatedCompileOptions} options
 * @param {string} source_name
 */
function merge_with_preprocessor_map(result, options, source_name) {
	if (options.sourcemap) {
		const file_basename = get_basename(options.filename || 'input.svelte');
		// The preprocessor map is expected to contain `sources: [basename_of_filename]`, but our own
		// map may contain a different file name. Patch our map beforehand to align sources so merging
		// with the preprocessor map works correctly.
		result.map.sources = [file_basename];
		result.map = apply_preprocessor_sourcemap(
			file_basename,
			result.map,
			/** @type {any} */ (options.sourcemap)
		);
		// After applying the preprocessor map, we need to do the inverse and make the sources
		// relative to the input file again in case the output code is in a different directory.
		if (file_basename !== source_name) {
			result.map.sources = result.map.sources.map(
				/** @param {string} source */ (source) => get_relative_path(source_name, source)
			);
		}
	}
}

/**
 * @param {import('../types').Analysis} analysis
 * @param {string} source
 * @param {import('#compiler').ValidatedModuleCompileOptions} options
 * @returns {import('#compiler').CompileResult}
 */
export function transform_module(analysis, source, options) {
	if (options.generate === false) {
		return {
			js: /** @type {any} */ (null),
			css: null,
			warnings: transform_warnings(source, analysis.name, analysis.warnings),
			metadata: {
				runes: true
			}
		};
	}

	const program =
		options.generate === 'server'
			? server_module(analysis, options)
			: client_module(analysis, options);

	const basename = (options.filename ?? 'Module').split(/[/\\]/).at(-1);
	if (program.body.length > 0) {
		program.body[0].leadingComments = [
			{
				type: 'Block',
				value: ` ${basename} generated by Svelte v${VERSION} `
			}
		];
	}

	return {
		js: print(program, {}),
		css: null,
		warnings: transform_warnings(source, analysis.name, analysis.warnings),
		metadata: {
			runes: true
		}
	};
}

/**
 * @param {string} source
 * @param {string | undefined} name
 * @param {import('../types').RawWarning[]} warnings
 * @returns {import('#compiler').Warning[]}
 */
function transform_warnings(source, name, warnings) {
	if (warnings.length === 0) return [];

	const locate = getLocator(source, { offsetLine: 1 });

	/** @type {import('#compiler').Warning[]} */
	const result = [];

	for (const warning of warnings) {
		const start =
			warning.position &&
			/** @type {import('locate-character').Location} */ (locate(warning.position[0]));

		const end =
			warning.position &&
			/** @type {import('locate-character').Location} */ (locate(warning.position[1]));

		result.push({
			start,
			end,
			filename: name,
			message: warning.message,
			code: warning.code
		});
	}

	return result;
}
